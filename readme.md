# **ToonLoader**

chrome and while extention (made by chrome api)


### Purpose
현재단계 : 네이버만 된다.
[ㅇ] 웹툰 정주행시 다음버튼을 누르는 동작을 없애자
[ㅇ] 웹툰을 볼 때 이름으로 검색하여 로드한다.
* 원하는 회차로 갈 수 있다.
* 돔에서 일정개수의 이미지를 유지한다(메모리 최적화 관련)
* 호환 플랫폼순서는 네이버-다음-레진 순으로 개발

### 마주친 고난

* html 파싱위기
  + 네이버.. 웹툰검색하면 서버사이드렌더링.. 검색하면 잘찾아지는 이유가있었다...(ssr이 seo에 좋다고 들어서..)
  + 다음은 json으로 데이터 제공해주고..
  + 간단하게 데이터로만 처리 할 생각이었는데..
    - 어차피 html도 데이터니까 그냥 진행한다.. 파싱한다
  + 네이버 서치엔진에서 만화 한 화의 제목까지 서치한다.
    - 이름서치결과만 뜨게 바꾼다.

* cors
  + 또 cors문제를 마주쳣다.
  + 서버사이드 해결 말고 클라이언트 사이드에서 해결해보고싶어서 찾아본결과 프록시를 작성해야한다 한다(아이오닉에서 한번 해본적 있는거같다.)
  + 어차피 flask로 서버하나 짜고싶었으니까 서버사이드를 추가해서 해결할까싶다...
    - cors 문제 popup view를 로컬에서 키고있다는걸 깨닫고 따로 chrome extention 실행하면서 debug과정으로 옮겻다.
    - 정답이었던게, manifes파일에 permission에 url을 추가 할 수 있는데
    By adding hosts or host match patterns (or both) to the permissions section of the manifest file, the extension can request access to remote servers outside of its origin
    외부 원격서버에 접근할 수 있게해준다.
    - 클라이언트 사이드에서 해결하는게 이상해서 검색해본 결과 permission에 프록시를 추가해서 해결하는 방식이다.
    - 현재까지 클라이언트 사이드에서의 대응은 프록시를 추가하여 해결하는 방법밖에 못본거같다. (백엔드 개입없이)
* 이미지 크롤링
  + naver: 엔드포인트에서 직접 가져오려고 했지만, 엔드포인트 uri가 다르다.
    - 하지만 웹툰 뷰어에서의 uri는 동일하므로 여기서 html파싱을 이미지 주소만 가져오자
    - 볼 수 있는 권한이 없으면 302code 그리고 redirect to list
    - chromeApi 중 webRequest에서 인터셉터 역할을 하는 onBeforeSendHeaders에 리스터 추가해서 해결, 그냥 XMLHttpRequest는 Referer가 설정이 안된다.
  + referer: 헤더에 referer가 네이버가 아니면 이미지 크롤링 권한문제 발생, 해결방법찾는중
  + daum: 다음같은 경우는 서버사이드 렌더링이 아니라 우선 뷰어를 주고 데이터 요청으로 띄우기 때문에 article id를 찾고, article 띄우면 가능
    - 두번의 절차.
    - 먼저 각 화에 대한 정보를 리퀘스트, 그리고 그 정보로 이미지가 저장된 주소 가져올수있음.(timestamp를 수집하는거같으니까 찍어주자)

### 프로젝트 중간에 멈춘 이유

* 크롤링에는 문제가 없다 하지만 cors가 애초에 보안을 위한 정책인데 웹툰을 클라이언트에서 크롤링해서 보는것은 문제가 있지 않냐는 이야기를 듣고 김이 팍셋다..
    - 확실히 same policy정책을 어기고 크롤링한거라서 이를 반박할 말이없다.(적어도 user agent정보는 같이 가지만..)
* 사실 이 프로젝트는 air bnb es6 코딩 컨벤션을 사용해보고 싶어서 썻다. 그리고 dom api.
    - 목적을 이뤘다. 실제로 domapi도 썻다. 우선 기능적으로 구현하여 배포전에 디자인적인면을 다 고칠 생각이어서 미학적인 면이 없다..
* 나중에 할 것(한가해지면)
    - 돔 개수를 일정하게 유지해본다.(이 부분은 어떻게 구현할지 생각은 해두었는데 재밌을거같다.)
        + 현재 뷰포트에서 어떤 엘리먼트가 떠있는지 기준으로 바디에 3개의 화만 넣어놓는다
        + 위로가면 최신화 하나를 지우고 이전 화 하나를 가져와서 3개를 유지한다.
        + 각 이미지 태그를 div로 회차로 관리한다.(이 쪽이 관리도 편하고 div안에 넣엇 돔에 한번에 넣는다면 더 빠르다(critical rendering path에서 렌더링 트리를 몇번이나 거쳐서 레이아웃도 몇번이나 거치지 않아도 되니까))
